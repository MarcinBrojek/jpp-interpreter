-- File generated by the BNF Converter (bnfc 2.9.4).

{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE PatternSynonyms #-}

-- | The abstract syntax of language grammar.

module AbsGrammar where

import Prelude (Integer, String)
import qualified Prelude as C
  ( Eq, Ord, Show, Read
  , Functor, Foldable, Traversable
  , Int, Maybe(..)
  )
import qualified Data.String

type Program = Program' BNFC'Position
data Program' a = Program a [Decl' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Decl = Decl' BNFC'Position
data Decl' a
    = DeclFunc a (Type' a) Ident [InitArg' a] (Body' a)
    | DeclProc a Ident [InitArg' a] (Body' a)
    | DeclVars a (Type' a) [InitVar' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type InitArg = InitArg' BNFC'Position
data InitArg' a
    = ArgWithValue a (Type' a) Ident (Expr' a)
    | ArgRefWithValue a (Type' a) Ident (Expr' a)
    | ArgWithoutValue a (Type' a) Ident
    | ArgRefWithoutValue a (Type' a) Ident
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type InitVar = InitVar' BNFC'Position
data InitVar' a
    = VarWithValue a Ident (Expr' a) | VarWithoutValue a Ident
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Body = Body' BNFC'Position
data Body' a = Body a [Instr' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Instr = Instr' BNFC'Position
data Instr' a
    = LocalDeclFunc a (Type' a) Ident [InitArg' a] (Body' a)
    | LocalDeclProc a Ident [InitArg' a] (Body' a)
    | LocalDeclVars a (Type' a) [InitVar' a]
    | FuncReturn a (Expr' a)
    | ProcReturn a
    | Skip a
    | ExecProc a Ident [Expr' a]
    | While a (Expr' a) (Body' a)
    | If a (Expr' a) (Body' a)
    | IfElse a (Expr' a) (Body' a) (Body' a)
    | For a (Type' a) [InitVar' a] (Expr' a) (Var' a) (Modif' a) (Body' a)
    | Break a
    | Countinue a
    | PushBack a Ident (Expr' a)
    | PopBack a Ident
    | PushFront a Ident (Expr' a)
    | PopFront a Ident
    | Cout a [CoutArgs' a]
    | VarModif a (Var' a) (Modif' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type CoutArgs = CoutArgs' BNFC'Position
data CoutArgs' a = CoutArgs a (Expr' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Modif = Modif' BNFC'Position
data Modif' a
    = Iinc a
    | IaddValue a (Expr' a)
    | Idec a
    | IdecValue a (Expr' a)
    | IandEq a (Expr' a)
    | IorEq a (Expr' a)
    | Imod a (Expr' a)
    | Itimes a (Expr' a)
    | Idiv a (Expr' a)
    | Iassign a (Expr' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Var = Var' BNFC'Position
data Var' a
    = Var a Ident | VarStringEl a Ident (Expr' a) | VarTie a [TieEl' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type TieEl = TieEl' BNFC'Position
data TieEl' a = TieEl a (Var' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Type = Type' BNFC'Position
data Type' a
    = Int a | Bool a | String a | Tuple a [Type' a] | List a (Type' a)
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type Expr = Expr' BNFC'Position
data Expr' a
    = Eor a (Expr' a) (Expr' a)
    | Eand a (Expr' a) (Expr' a)
    | Ecmp a (Expr' a) (CmpOp' a) (Expr' a)
    | Ecomplex a (ComplexVal' a)
    | Eadd a (Expr' a) (AddOp' a) (Expr' a)
    | Emul a (Expr' a) (MulOp' a) (Expr' a)
    | Eneg a (Expr' a)
    | Enot a (Expr' a)
    | Econst a (SimpleVal' a)
    | EeasyMethod a (Expr' a) (EasyMethod' a)
    | EhardMethod a (Expr' a) (HardMethod' a)
    | EstringEl a (Expr' a) (Expr' a)
    | Evariable a Ident
    | EexecFunc a Ident [Expr' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type CmpOp = CmpOp' BNFC'Position
data CmpOp' a
    = CmpLe a | CmpLeq a | CmpEq a | CmpGeq a | CmpGe a | CmpNeq a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type AddOp = AddOp' BNFC'Position
data AddOp' a = Plus a | Minus a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type MulOp = MulOp' BNFC'Position
data MulOp' a = Times a | Div a | Mod a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type EasyMethod = EasyMethod' BNFC'Position
data EasyMethod' a = Size a | Empty a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type HardMethod = HardMethod' BNFC'Position
data HardMethod' a = Get a (Expr' a) | Back a | Front a
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type SimpleVal = SimpleVal' BNFC'Position
data SimpleVal' a
    = ConstInt a Integer
    | ConstBoolTrue a
    | ConstBoolFalse a
    | ConstString a String
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

type ComplexVal = ComplexVal' BNFC'Position
data ComplexVal' a
    = ConstTuple a [Expr' a] | ConstList a (Type' a) [Expr' a]
  deriving (C.Eq, C.Ord, C.Show, C.Read, C.Functor, C.Foldable, C.Traversable)

newtype Ident = Ident String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

-- | Start position (line, column) of something.

type BNFC'Position = C.Maybe (C.Int, C.Int)

pattern BNFC'NoPosition :: BNFC'Position
pattern BNFC'NoPosition = C.Nothing

pattern BNFC'Position :: C.Int -> C.Int -> BNFC'Position
pattern BNFC'Position line col = C.Just (line, col)

-- | Get the start position of something.

class HasPosition a where
  hasPosition :: a -> BNFC'Position

instance HasPosition Program where
  hasPosition = \case
    Program p _ -> p

instance HasPosition Decl where
  hasPosition = \case
    DeclFunc p _ _ _ _ -> p
    DeclProc p _ _ _ -> p
    DeclVars p _ _ -> p

instance HasPosition InitArg where
  hasPosition = \case
    ArgWithValue p _ _ _ -> p
    ArgRefWithValue p _ _ _ -> p
    ArgWithoutValue p _ _ -> p
    ArgRefWithoutValue p _ _ -> p

instance HasPosition InitVar where
  hasPosition = \case
    VarWithValue p _ _ -> p
    VarWithoutValue p _ -> p

instance HasPosition Body where
  hasPosition = \case
    Body p _ -> p

instance HasPosition Instr where
  hasPosition = \case
    LocalDeclFunc p _ _ _ _ -> p
    LocalDeclProc p _ _ _ -> p
    LocalDeclVars p _ _ -> p
    FuncReturn p _ -> p
    ProcReturn p -> p
    Skip p -> p
    ExecProc p _ _ -> p
    While p _ _ -> p
    If p _ _ -> p
    IfElse p _ _ _ -> p
    For p _ _ _ _ _ _ -> p
    Break p -> p
    Countinue p -> p
    PushBack p _ _ -> p
    PopBack p _ -> p
    PushFront p _ _ -> p
    PopFront p _ -> p
    Cout p _ -> p
    VarModif p _ _ -> p

instance HasPosition CoutArgs where
  hasPosition = \case
    CoutArgs p _ -> p

instance HasPosition Modif where
  hasPosition = \case
    Iinc p -> p
    IaddValue p _ -> p
    Idec p -> p
    IdecValue p _ -> p
    IandEq p _ -> p
    IorEq p _ -> p
    Imod p _ -> p
    Itimes p _ -> p
    Idiv p _ -> p
    Iassign p _ -> p

instance HasPosition Var where
  hasPosition = \case
    Var p _ -> p
    VarStringEl p _ _ -> p
    VarTie p _ -> p

instance HasPosition TieEl where
  hasPosition = \case
    TieEl p _ -> p

instance HasPosition Type where
  hasPosition = \case
    Int p -> p
    Bool p -> p
    String p -> p
    Tuple p _ -> p
    List p _ -> p

instance HasPosition Expr where
  hasPosition = \case
    Eor p _ _ -> p
    Eand p _ _ -> p
    Ecmp p _ _ _ -> p
    Ecomplex p _ -> p
    Eadd p _ _ _ -> p
    Emul p _ _ _ -> p
    Eneg p _ -> p
    Enot p _ -> p
    Econst p _ -> p
    EeasyMethod p _ _ -> p
    EhardMethod p _ _ -> p
    EstringEl p _ _ -> p
    Evariable p _ -> p
    EexecFunc p _ _ -> p

instance HasPosition CmpOp where
  hasPosition = \case
    CmpLe p -> p
    CmpLeq p -> p
    CmpEq p -> p
    CmpGeq p -> p
    CmpGe p -> p
    CmpNeq p -> p

instance HasPosition AddOp where
  hasPosition = \case
    Plus p -> p
    Minus p -> p

instance HasPosition MulOp where
  hasPosition = \case
    Times p -> p
    Div p -> p
    Mod p -> p

instance HasPosition EasyMethod where
  hasPosition = \case
    Size p -> p
    Empty p -> p

instance HasPosition HardMethod where
  hasPosition = \case
    Get p _ -> p
    Back p -> p
    Front p -> p

instance HasPosition SimpleVal where
  hasPosition = \case
    ConstInt p _ -> p
    ConstBoolTrue p -> p
    ConstBoolFalse p -> p
    ConstString p _ -> p

instance HasPosition ComplexVal where
  hasPosition = \case
    ConstTuple p _ -> p
    ConstList p _ _ -> p

